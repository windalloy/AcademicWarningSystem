# 数据库范式分析报告

## 三大范式基本要求

- **第一范式（1NF）**：每个属性都是原子值，不可再分
- **第二范式（2NF）**：在1NF基础上，非主属性完全依赖于主键（不能部分依赖）
- **第三范式（3NF）**：在2NF基础上，非主属性不传递依赖于主键（消除冗余）

---

## 表结构分析

### 1. Student（学生表）

**主键**：SNo（学号）

**字段**：
- SNo（学号）- 主键
- SName（姓名）
- Dept（院系）
- EnrollmentYear（入学年份）
- TotalCredit（总已获学分）
- GPA（平均绩点）

**范式检查**：

✅ **第一范式（1NF）**：符合
- 所有字段都是原子值，不可再分

✅ **第二范式（2NF）**：符合
- 主键是单属性（SNo）
- 所有非主属性都完全依赖于主键

⚠️ **第三范式（3NF）**：**存在冗余**
- **问题**：TotalCredit 和 GPA 是冗余字段
- **原因**：这两个字段可以通过 Score 表计算得出
- **影响**：数据冗余，可能导致数据不一致
- **说明**：虽然冗余，但这是**设计上的权衡**，用于提高查询性能（避免每次查询都计算）

---

### 2. Course（课程表）

**主键**：CNo（课程号）

**字段**：
- CNo（课程号）- 主键
- CName（课程名）
- Credit（学分）
- CourseType（课程类型）

**范式检查**：

✅ **第一范式（1NF）**：符合
- 所有字段都是原子值

✅ **第二范式（2NF）**：符合
- 主键是单属性
- 所有非主属性完全依赖于主键

✅ **第三范式（3NF）**：符合
- 所有非主属性都直接依赖于主键，无传递依赖

---

### 3. Score（成绩表）

**主键**：(SNo, CNo, Semester) - 联合主键

**字段**：
- SNo（学号）- 主键的一部分
- CNo（课程号）- 主键的一部分
- Semester（学期）- 主键的一部分
- ScoreValue（成绩）
- GPA_Point（绩点）
- Is_Passed（是否通过）

**范式检查**：

✅ **第一范式（1NF）**：符合
- 所有字段都是原子值

⚠️ **第二范式（2NF）**：**存在部分依赖**
- **问题**：GPA_Point 和 Is_Passed 不完全依赖于主键
- **原因**：这两个字段实际上只依赖于 ScoreValue，而不是主键 (SNo, CNo, Semester)
- **说明**：虽然理论上违反2NF，但这是**设计上的权衡**，因为：
  - GPA_Point 和 Is_Passed 是 ScoreValue 的**派生属性**（通过触发器自动计算）
  - 存储这些值可以提高查询性能，避免每次查询都计算
  - 这是**反范式化**的常见做法

✅ **第三范式（3NF）**：基本符合
- 虽然有冗余，但属于合理的反范式化设计

---

### 4. GraduationRequirement（毕业要求表）

**主键**：ReqID（要求ID）

**字段**：
- ReqID（要求ID）- 主键（自增）
- Dept（适用院系）- UNIQUE
- TotalCreditRequired（总学分要求）
- CoreCourseFailLimit（核心课不及格数量上限）
- MinGPA（最低GPA要求）

**范式检查**：

✅ **第一范式（1NF）**：符合

✅ **第二范式（2NF）**：符合
- 主键是单属性
- 所有非主属性完全依赖于主键

✅ **第三范式（3NF）**：符合
- 所有非主属性都直接依赖于主键

---

### 5. CoreCourse（核心课程表）

**主键**：(Dept, CNo) - 联合主键

**字段**：
- Dept（院系）- 主键的一部分
- CNo（课程号）- 主键的一部分

**范式检查**：

✅ **第一范式（1NF）**：符合

✅ **第二范式（2NF）**：符合
- 联合主键的两个属性都是必要的
- 没有部分依赖

✅ **第三范式（3NF）**：符合
- 表结构简单，无传递依赖

---

## 总结

### 符合范式的情况

| 表名 | 1NF | 2NF | 3NF | 说明 |
|------|-----|-----|-----|------|
| Student | ✅ | ✅ | ⚠️ | TotalCredit和GPA冗余（性能优化） |
| Course | ✅ | ✅ | ✅ | 完全符合 |
| Score | ✅ | ⚠️ | ✅ | GPA_Point和Is_Passed冗余（性能优化） |
| GraduationRequirement | ✅ | ✅ | ✅ | 完全符合 |
| CoreCourse | ✅ | ✅ | ✅ | 完全符合 |

### 存在的问题

1. **Student 表的冗余字段**
   - TotalCredit 和 GPA 可以通过 Score 表计算
   - **但这是合理的反范式化**，用于提高查询性能

2. **Score 表的冗余字段**
   - GPA_Point 和 Is_Passed 依赖于 ScoreValue
   - **但这是合理的反范式化**，通过触发器自动维护

### 设计评价

**优点**：
- ✅ 基本符合三大范式
- ✅ 使用了合理的反范式化优化
- ✅ 通过触发器自动维护冗余数据的一致性
- ✅ 表结构清晰，关系明确

**建议**：
- 当前设计是**合理的**，在范式化和性能之间取得了平衡
- 冗余字段通过触发器自动维护，保证了数据一致性
- 如果追求严格的范式化，可以：
  1. 移除 Student 表的 TotalCredit 和 GPA，改为通过视图计算
  2. 移除 Score 表的 GPA_Point 和 Is_Passed，改为通过视图计算
  - **但这样会降低查询性能**

---

## 结论

**当前数据库设计基本符合三大范式，存在的冗余是合理的反范式化设计，用于提高性能。**

在数据库设计中，**范式化**和**性能**之间需要权衡：
- 严格的范式化可以减少冗余，但可能影响查询性能
- 适当的反范式化可以提高性能，但需要保证数据一致性

当前设计通过触发器自动维护冗余数据，既保证了性能，又保证了数据一致性，是**良好的设计实践**。

