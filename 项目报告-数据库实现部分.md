# 4. 数据库实现

## 4.1 数据库创建脚本

### 4.1.1 数据库架构设计

本系统采用 MySQL 8.0 作为数据库管理系统，数据库命名为 `AcademicWarningSystem`。数据库设计严格遵循关系数据库的三大范式，确保数据的一致性和完整性。

**字符集选择**：采用 `utf8mb4` 字符集和 `utf8mb4_unicode_ci` 排序规则，确保能够正确存储和处理中文字符，满足学生姓名、课程名称等中文数据的存储需求。

### 4.1.2 数据表设计

系统共设计了 5 张核心数据表，每张表都经过精心设计，确保符合业务需求和数据规范化要求：

**（1）Student（学生表）**
学生表是系统的核心实体之一，存储学生的基本信息。设计时严格遵循第三范式，仅存储学生的固有属性：学号作为主键，姓名、院系、入学年份作为基本属性。值得注意的是，为了消除数据冗余，本表不存储计算属性（如总学分、GPA），这些值通过视图动态计算获得，既保证了数据一致性，又符合规范化设计原则。

**（2）Course（课程表）**
课程表存储课程的基本信息，包括课程号（主键）、课程名、学分和课程类型。课程类型采用 ENUM 类型约束，限定为"核心"、"通识"、"选修"三种类型，通过数据库层面的约束保证数据的有效性。学分字段设置了 CHECK 约束，确保学分值必须大于 0，防止数据录入错误。

**（3）Score（成绩表）**
成绩表采用联合主键设计，由学号、课程号和学期三个字段组成，这种设计允许同一学生在不同学期选修同一门课程，符合实际教学场景。成绩字段设置了范围约束（0-100），确保数据的合理性。该表通过外键关联学生表和课程表，并设置了级联删除策略，当删除学生或课程时，相关成绩记录会自动删除，保证数据的完整性。

**（4）GraduationRequirement（毕业要求表）**
毕业要求表为每个院系定义了毕业标准，包括总学分要求、核心课程不及格数量上限和最低 GPA 要求。院系字段设置为唯一约束，确保每个院系只有一个毕业要求配置。这种设计使得不同院系可以有不同的毕业标准，体现了系统的灵活性和可扩展性。

**（5）CoreCourse（核心课程表）**
核心课程表建立了院系与核心课程之间的多对多关系。采用联合主键（院系、课程号），允许同一门课程成为多个院系的核心课程，同时也允许同一院系有多门核心课程。这种设计支持不同院系有不同的核心课程体系，符合实际教学管理需求。

### 4.1.3 约束与索引设计

**主键约束**：每张表都设置了合适的主键，Student 和 Course 使用单字段主键，Score 和 CoreCourse 使用联合主键，体现了不同业务场景的需求。

**外键约束**：所有外键都设置了 `ON DELETE CASCADE` 和 `ON UPDATE CASCADE`，确保数据的一致性和完整性。当主表记录被删除或更新时，相关从表记录会自动处理，避免出现孤立数据。

**检查约束**：在关键字段上设置了 CHECK 约束，如成绩范围（0-100）、学分必须大于 0 等，在数据库层面保证数据的有效性。

**索引设计**：在常用查询字段上建立了索引，如学生表的院系字段、课程表的课程类型字段、成绩表的学期字段等，显著提高了查询性能。

---

## 4.2 视图设计与实现

### 4.2.1 视图设计理念

视图是数据库设计中的重要组成部分，本系统通过视图实现了数据的逻辑抽象和计算属性的动态获取。视图的设计遵循"计算而非存储"的原则，所有派生数据都通过视图实时计算，避免了数据冗余，保证了数据的一致性。

### 4.2.2 核心视图实现

**（1）StudentGPAView（学生 GPA 视图）**

该视图是系统的核心视图之一，实现了学生平均绩点和已获学分的动态计算。

**设计原理**：
- 通过 LEFT JOIN 关联学生表、成绩表和课程表，确保即使没有成绩记录的学生也能显示（GPA 和学分为 0）
- 使用聚合函数 `SUM()` 和条件表达式 `CASE WHEN` 计算已获学分，只统计成绩≥60 分的课程
- GPA 计算采用加权平均方法：GPA = Σ(绩点 × 学分) / Σ(学分)，其中绩点通过 `fn_CalculateGPA()` 函数计算
- 使用 `COALESCE()` 函数处理空值，确保计算结果始终为数值类型

**业务价值**：该视图实现了学生学业成绩的实时统计，每次查询都能获得最新的 GPA 和学分信息，无需维护冗余字段，体现了规范化设计的优势。

**（2）FailedCoreCoursesView（核心课程不及格视图）**

该视图专门用于筛选核心课程不及格的学生记录，是学业预警功能的重要数据源。

**设计原理**：
- 通过多表连接（学生表、成绩表、课程表、核心课程表）筛选出核心课程不及格的记录
- 使用 `fn_IsPassed()` 函数判断成绩是否通过，只有未通过的记录才会被筛选出来
- 通过 `INNER JOIN` 确保只显示确实存在核心课程不及格情况的学生
- 结果按学号和学期排序，便于查看学生的学业发展轨迹

**业务价值**：该视图为预警系统提供了核心课程不及格的数据基础，管理员可以快速识别需要关注的学生，体现了数据库视图在业务逻辑封装方面的优势。

**（3）CreditsCompletedView（学分完成情况视图）**

该视图统计每位学生已获得的学分总数，是评估学生学业进度的重要指标。

**设计原理**：
- 使用 LEFT JOIN 确保所有学生都出现在结果中，即使没有成绩记录
- 通过条件聚合只统计已通过课程（成绩≥60）的学分
- 使用 `COALESCE()` 处理空值，确保没有成绩的学生显示为 0 学分

**业务价值**：该视图提供了学生学业进度的量化指标，结合毕业要求表，可以快速判断学生是否达到毕业学分要求，为学业预警提供数据支持。

**（4）FailedCoursesView（所有未通过课程视图）**

该视图提供了更全面的不及格课程信息，不仅限于核心课程。

**设计原理**：
- 通过学生表、成绩表、课程表的连接，筛选出所有未通过的课程
- 包含课程类型信息，便于区分不同类型的未通过课程
- 提供完整的课程信息（课程号、课程名、学分、课程类型），便于全面了解学生的学业状况

**业务价值**：该视图为学业分析提供了全面的数据支持，管理员可以了解学生所有未通过的课程，而不仅仅是核心课程，有助于更全面地评估学生的学业状况。

### 4.2.3 视图设计的优势

**数据一致性**：通过视图计算派生数据，避免了数据冗余，确保了数据的一致性。当基础数据发生变化时，视图查询结果自动更新，无需手动维护。

**性能优化**：虽然视图需要实时计算，但通过合理的索引设计和查询优化，查询性能仍然可以接受。对于频繁查询的场景，可以考虑物化视图（MySQL 8.0 支持）。

**业务逻辑封装**：视图将复杂的业务逻辑封装在数据库层，应用程序只需简单查询视图即可获得所需数据，降低了应用层的复杂度。

---

## 4.3 存储过程设计与实现

### 4.3.1 存储过程设计理念

存储过程是数据库编程的重要工具，本系统使用存储过程实现了复杂的业务逻辑，特别是学业预警的自动筛选功能。将业务逻辑放在数据库层，可以充分利用数据库的查询优化能力，提高执行效率，同时保证逻辑的一致性和可维护性。

### 4.3.2 核心存储过程：usp_GenerateWarningList

**功能概述**：该存储过程是系统的核心业务逻辑实现，用于自动筛选出需要学业预警的学生名单。预警条件基于毕业要求表中的配置，实现了灵活的预警策略。

**预警条件设计**：

**条件一：学分不足预警**
- **判断标准**：学生已获学分 < 毕业要求总学分的 80%
- **实现原理**：通过子查询动态计算学生的已获学分，与毕业要求表中的总学分要求进行比较。使用 `COALESCE()` 和条件聚合函数，只统计已通过课程（成绩≥60）的学分。
- **业务意义**：该条件用于识别学业进度滞后的学生，80% 的阈值可以根据实际需求调整，体现了系统的灵活性。

**条件二：核心课程不及格预警**
- **判断标准**：学生核心课程不及格数量 ≥ 毕业要求中设定的上限
- **实现原理**：通过子查询统计学生核心课程不及格的数量。查询需要关联成绩表、核心课程表，并使用 `fn_IsPassed()` 函数判断是否通过。核心课程的判断基于学生所在院系和课程是否在该院系的核心课程清单中。
- **业务意义**：核心课程是学生专业能力培养的关键，该条件用于识别核心课程学习存在问题的学生，及时进行学业干预。

**预警原因分析**：
存储过程使用 `CASE WHEN` 语句判断预警原因，优先显示学分不足（如果同时满足两个条件）。预警原因以中文描述，便于管理员理解。同时输出学生的已获学分、要求学分、核心课程不及格数等详细信息，为后续的学业指导提供数据支持。

**查询优化**：
- 使用子查询而非连接，避免产生笛卡尔积
- 通过索引优化提高查询效率
- 使用函数封装判断逻辑，提高代码可读性

**业务价值**：
该存储过程实现了学业预警的自动化，管理员只需调用一个存储过程即可获得完整的预警学生名单，大大提高了工作效率。同时，预警条件基于毕业要求表的配置，不同院系可以有不同的预警标准，体现了系统的灵活性和可扩展性。

---

## 4.4 触发器设计与实现

### 4.4.1 触发器设计理念

触发器是数据库自动化的重要机制，可以在数据变更时自动执行预定义的操作。本系统在设计时严格遵循三大范式，不存储冗余字段，因此触发器的设计重点在于数据验证和完整性保证，而非数据计算和更新。

### 4.4.2 触发器实现

**（1）trg_AfterInsert_Score_Validate（插入成绩后验证触发器）**

**触发时机**：在成绩表插入新记录后自动触发。

**功能设计**：
- **数据验证**：虽然成绩字段已经设置了 CHECK 约束（0-100），触发器可以在此基础上进行更复杂的验证逻辑，如检查成绩的合理性（如是否存在异常高分或低分）。
- **日志记录**：触发器预留了日志记录功能，可以记录每次成绩录入的操作，包括操作时间、操作人员等信息，为数据审计提供支持。
- **扩展性**：触发器结构设计为可扩展，未来可以添加更多的验证逻辑，如检查学生是否已选该课程、学期是否有效等。

**设计考虑**：
由于系统严格遵循三大范式，不存储冗余字段（如 GPA_Point、Is_Passed），因此触发器不进行数据计算和更新操作。所有计算值通过视图和函数动态获取，保证了数据的一致性和规范性。

**（2）trg_AfterUpdate_Score_Validate（更新成绩后验证触发器）**

**触发时机**：在成绩表更新记录后自动触发。

**功能设计**：
- **变更验证**：验证更新后的成绩值是否在合理范围内，确保数据修改的合法性。
- **变更追踪**：可以记录成绩的变更历史，包括原值、新值、变更时间等信息，为成绩管理提供审计追踪功能。
- **业务规则验证**：可以验证业务规则，如是否允许修改已确认的成绩、修改权限检查等。

**设计考虑**：
更新触发器与插入触发器采用相同的设计理念，重点在于数据验证和完整性保证，而非数据计算。这种设计符合规范化数据库设计原则，避免了数据冗余和不一致问题。

### 4.4.3 触发器设计的优势

**数据完整性**：通过触发器在数据库层面进行数据验证，确保只有符合业务规则的数据才能被存储，提高了数据的质量和可靠性。

**自动化处理**：触发器自动执行，无需应用程序干预，减少了应用层的代码复杂度，同时保证了逻辑的一致性。

**可扩展性**：触发器结构设计为可扩展，未来可以根据业务需求添加更多的验证逻辑和自动化处理，而无需修改应用程序代码。

**审计支持**：触发器可以记录数据变更的详细信息，为数据审计和问题追踪提供支持，这在教学管理中非常重要。

### 4.4.4 设计权衡

本系统的触发器设计体现了规范化设计与实际需求之间的权衡：

**规范化优先**：系统严格遵循三大范式，不存储冗余字段，所有计算值通过视图和函数动态获取。这种设计保证了数据的一致性，避免了数据冗余带来的维护问题。

**功能完整性**：虽然触发器不进行数据计算，但通过视图、函数和存储过程的组合，系统仍然能够提供完整的功能，包括 GPA 计算、学分统计、预警筛选等。

**性能考虑**：虽然视图查询需要实时计算，但通过合理的索引设计和查询优化，性能仍然可以接受。对于大规模数据，可以考虑使用物化视图或缓存机制。

---

## 4.5 数据库实现总结

### 4.5.1 设计特点

本系统的数据库实现体现了以下特点：

**（1）严格规范化**
- 所有表设计严格遵循三大范式
- 无冗余字段，所有计算值通过视图和函数动态获取
- 通过外键约束保证数据完整性

**（2）业务逻辑封装**
- 通过视图封装复杂的数据聚合逻辑
- 通过存储过程实现复杂的业务规则
- 通过函数实现可复用的计算逻辑

**（3）自动化机制**
- 通过触发器实现数据验证
- 通过视图实现数据自动计算
- 通过存储过程实现业务自动处理

**（4）灵活性和可扩展性**
- 毕业要求可配置，不同院系可以有不同的标准
- 核心课程可配置，支持不同院系的核心课程体系
- 视图和存储过程易于扩展，支持未来功能增强

### 4.5.2 技术亮点

**（1）函数化设计**
通过 `fn_CalculateGPA()` 和 `fn_IsPassed()` 函数，将计算逻辑封装在数据库层，实现了逻辑的复用和一致性。

**（2）视图化计算**
通过视图实现 GPA 和学分的动态计算，避免了数据冗余，保证了数据一致性。

**（3）存储过程自动化**
通过存储过程实现预警筛选的自动化，提高了工作效率，同时保证了逻辑的一致性。

**（4）约束完整性**
通过主键、外键、唯一约束、检查约束等多层约束，在数据库层面保证数据的完整性和有效性。

### 4.5.3 实际应用价值

本系统的数据库实现不仅满足了学业预警与成绩分析的功能需求，更重要的是体现了规范化数据库设计的最佳实践：

- **数据一致性**：通过规范化设计避免了数据冗余，确保了数据的一致性
- **可维护性**：通过视图、函数、存储过程封装业务逻辑，提高了系统的可维护性
- **可扩展性**：通过灵活的配置和模块化设计，支持未来功能的扩展
- **性能优化**：通过合理的索引设计和查询优化，保证了系统的性能

这些设计原则和实现方法不仅适用于学业预警系统，也可以应用于其他类似的管理信息系统，具有很好的参考价值。

---

# 5. 数据操作与查询

## 5.1 模拟数据插入

### 5.1.1 数据设计原则

为了验证系统的功能和性能，本系统设计了完整的模拟数据集。数据设计遵循以下原则：

**（1）数据完整性**：确保所有表都有数据，覆盖各种业务场景，包括正常情况、异常情况和边界情况。

**（2）数据关联性**：确保数据之间的关联关系正确，学生、课程、成绩、毕业要求、核心课程之间形成完整的业务闭环。

**（3）业务真实性**：模拟数据贴近实际教学场景，包括不同院系、不同年级、不同课程类型、不同成绩分布等。

### 5.1.2 模拟数据内容

**学生数据**：共7名学生，涵盖3个院系（计算机科学、数学、物理），2个入学年份（2021年、2022年），体现了系统的多院系、多年级管理能力。

**课程数据**：共11门课程，包括核心课程（如数据结构、算法设计、数学分析）、通识课程（如大学英语、高等数学）、选修课程（如音乐欣赏、体育），覆盖了所有课程类型。

**成绩数据**：共20条成绩记录，包括正常成绩（60分以上）、不及格成绩（60分以下）、不同学期的成绩分布、不同学生的成绩差异。

**毕业要求数据**：为3个院系分别设置了毕业要求，包括总学分要求（110-120学分）、核心课程不及格上限（1-2门）、最低GPA要求（2.50-2.80），体现了不同院系的不同标准。

**核心课程数据**：为每个院系设置了核心课程清单，如计算机科学专业的核心课程包括数据结构、算法设计、数据库系统、软件工程等，体现了专业特色。

### 5.1.3 数据插入策略

数据插入采用批量插入方式，使用 `INSERT INTO ... VALUES (...), (...), (...)` 语法，提高了插入效率。插入顺序遵循外键依赖关系：先插入学生和课程（主表），再插入成绩和核心课程（从表），确保外键约束不会报错。

---

## 5.2 复杂查询设计

### 5.2.1 查询设计思路

本系统设计了7个复杂查询示例，涵盖了学业预警系统的核心业务场景。这些查询展示了SQL的高级应用，包括多表连接、子查询、聚合函数、条件判断等。

### 5.2.2 核心查询示例

**（1）查询某学生所有不及格课程**：通过多表连接和条件筛选，使用 `fn_IsPassed()` 函数判断是否通过。

**（2）统计各院系平均GPA**：通过视图 `StudentGPAView` 获取数据，按院系分组统计，展示了视图在数据聚合中的应用。

**（3）查询核心课程挂科≥2门的学生**：通过多表连接和子查询统计，使用 `HAVING` 子句筛选，展示了子查询和分组统计的应用。

**（4）查询学分不足毕业要求80%的学生**：通过子查询动态计算已获学分，与毕业要求比较，展示了动态计算和条件判断。

**（5）查询每学期学生选课数量统计**：通过分组统计，使用聚合函数（COUNT、AVG）实现数据统计。

**（6）查询所有学生的详细成绩单**：通过多表连接，使用函数计算绩点和是否通过，生成完整成绩单。

**（7）执行预警存储过程**：通过调用存储过程 `usp_GenerateWarningList()`，自动生成预警学生名单。

### 5.2.3 查询设计特点

**函数化**：查询中大量使用自定义函数，实现了逻辑的复用和一致性。

**视图化**：部分查询通过视图获取数据，简化了查询语句，提高了可读性。

**动态计算**：查询中通过子查询和函数实现动态计算，避免了数据冗余，保证了数据一致性。

**业务导向**：所有查询都围绕实际业务需求设计，具有明确的业务价值。

---

## 5.3 业务逻辑实现

### 5.3.1 业务逻辑分层

本系统的业务逻辑采用分层设计：

**（1）数据库层**：核心业务逻辑在数据库层实现，包括函数（封装可复用的计算逻辑）、视图（封装复杂的数据聚合逻辑）、存储过程（封装复杂的业务规则）。

**（2）应用层**：数据访问和界面交互在应用层实现，包括数据访问（封装数据库操作）和界面交互（处理用户输入和输出）。

### 5.3.2 核心业务逻辑

**（1）GPA计算逻辑**：采用加权平均方法，绩点根据成绩分段计算。该逻辑通过函数 `fn_CalculateGPA()` 封装，在视图和查询中复用。

**（2）学分统计逻辑**：只统计已通过课程（成绩≥60）的学分。该逻辑通过函数 `fn_IsPassed()` 判断是否通过，在视图和查询中使用条件聚合实现。

**（3）预警筛选逻辑**：基于两个条件：学分不足（低于要求80%）或核心课程不及格数量超过上限。该逻辑通过存储过程 `usp_GenerateWarningList()` 实现，使用子查询动态计算，与毕业要求表中的配置进行比较。

### 5.3.3 业务逻辑特点

**自动化**：核心业务逻辑在数据库层自动执行，无需应用程序干预，保证了逻辑的一致性。

**可配置**：预警条件基于毕业要求表的配置，不同院系可以有不同的标准，体现了系统的灵活性。

**实时性**：所有计算值通过视图和函数实时获取，保证了数据的实时性和准确性。

**可扩展性**：业务逻辑采用模块化设计，易于扩展和维护。

---

## 5.4 数据操作与查询总结

本系统的数据操作与查询设计体现了以下特点：

**（1）完整性**：模拟数据覆盖了所有业务场景，为系统测试和演示提供了完整的数据基础。

**（2）复杂性**：复杂查询展示了SQL的高级应用，包括多表连接、子查询、聚合函数、函数调用等，体现了数据库查询的强大能力。

**（3）业务性**：所有查询和业务逻辑都围绕实际业务需求设计，具有明确的业务价值，不是简单的技术演示。

**（4）规范性**：数据操作和查询严格遵循数据库设计规范，使用函数和视图封装逻辑，避免了代码重复，提高了可维护性。

这些设计不仅满足了学业预警系统的功能需求，也展示了规范化数据库设计和SQL高级应用的最佳实践。

---

# 6. 实验总结

## 6.1 设计总结

本系统通过严格遵循数据库三大范式，实现了规范化、高效、可维护的数据库设计。系统采用5张核心数据表，通过外键约束和检查约束保证了数据的完整性和有效性。通过4个视图实现了计算属性的动态获取，避免了数据冗余。通过2个自定义函数封装了可复用的计算逻辑，通过1个存储过程实现了复杂的业务规则。通过2个触发器框架为数据验证和审计提供了扩展空间。

系统设计充分考虑了实际业务需求，包括多院系管理、多年级管理、不同毕业要求配置等，体现了良好的灵活性和可扩展性。通过模拟数据和复杂查询示例，验证了系统的功能完整性和性能表现。

## 6.2 技术收获

**（1）规范化设计能力**：深入理解了数据库三大范式的应用，学会了如何通过视图和函数消除数据冗余，保证数据一致性。

**（2）SQL高级应用**：掌握了视图、函数、存储过程、触发器的设计和实现，学会了如何通过SQL实现复杂的业务逻辑。

**（3）数据库对象设计**：理解了不同数据库对象（表、视图、函数、存储过程、触发器）的适用场景和设计原则，学会了如何合理选择和使用这些对象。

**（4）业务逻辑分层**：理解了数据库层和应用层的职责划分，学会了如何将核心业务逻辑放在数据库层，提高系统的可靠性和一致性。

**（5）系统设计思维**：从需求分析到数据库设计，从表结构设计到业务逻辑实现，形成了完整的系统设计思维和方法论。

通过本次实验，不仅掌握了数据库设计的理论知识，更重要的是培养了解决实际问题的能力，为后续的数据库系统开发奠定了坚实的基础。

